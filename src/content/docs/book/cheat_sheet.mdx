---
title: Nushell Cheat Sheet
---

import { Code } from "@astrojs/starlight/components";

## Data types

```nushell frame="terminal"
# converts string to integer
"12" | into int
```

---

```nushell frame="terminal"
# converts present date to provided time zone
date now | date to-timezone "Europe/London"
```

---

```nushell frame="terminal"
# updates a record's language and if none is specified inserts provided value
{'name': 'nu', 'stars': 5, 'language': 'Python'} | upsert language 'Rust'
```

---

```nushell frame="terminal"
# converts list of strings to yaml
[one two three] | to yaml
```

---

```nushell frame="terminal"
# prints the table
[[framework, language]; [Django, Python] [Lavarel, PHP]]
```

---

```nushell frame="terminal"
# selects two columns from the table and prints their values
[{name: 'Robert' age: 34 position: 'Designer'}
     {name: 'Margaret' age: 30 position: 'Software Developer'}
     {name: 'Natalie' age: 50 position: 'Accountant'}
    ] | select name position
```

## Strings

```nushell frame="terminal"
# prints `greetings, Alice!`
let name = "Alice"
$"greetings, ($name)!"
```

---

```nushell frame="terminal"
# splits the string with specified delimiter and saves the list to `string_list` variable
let string_list = "one,two,three" | split row ","
$string_list
```

---

```nushell frame="terminal"
# checks if a string contains a substring and returns `boolean`
"Hello, world!" | str contains "o, w"
```

---

```nushell frame="terminal"
# joins the list of strings using provided delimiter
let str_list = [zero one two]
$str_list | str join ','
```

---

```nushell frame="terminal"
# created a slice from a given string with start (4) and end (8) indices
'Hello World!' | str substring 4..8
```

---

```nushell frame="terminal"
# parses the string to columns
'Nushell 0.80' | parse '{shell} {version}'
```

```nushell frame="terminal"
# parses comma separated values (csv)
"acronym,long\nAPL,A Programming Language" | from csv
```

```nushell frame="terminal"
# ansi command colors the text (alsways end with `ansi reset` to reset color to default)
$'(ansi purple_bold)This text is a bold purple!(ansi reset)'
```

## Lists

```nushell frame="terminal"
# inserts `beeze` value at st index in the list
[foo bar baz] | insert 1 'beeze'
```

---

```nushell frame="terminal"
# updates 2nd value to 10
[1, 2, 3, 4] | update 1 10
```

---

```nushell frame="terminal"
# adds value at the beginning of the list
let numbers = [1, 2, 3, 4, 5]
$numbers | prepend 0
```

---

```nushell frame="terminal"
# adds value at the end of the list
let numbers = [1, 2, 3, 4, 5]
$numbers | append 6
```

---

```nushell frame="terminal"
# creates slice of first two values from `flowers` list
let flowers = [cammomile marigold rose forget-me-not]
let flowers = ($flowers | first 2)
$flowers
```

---

```nushell frame="terminal"
# iterates over a list; `it` is current list value
let planets = [Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune]
$planets | each { |it| $"($it) is a planet of solar system" }
```

---

```nushell frame="terminal"
# iterates over a list and provides index and value in `it`
$planets | enumerate | each { |it| $"($it.index + 1) - ($it.item)" }
```

---

```nushell frame="terminal"
# reduces the list to a single value, `reduce` gives access to accumulator that is applied
# to each element in the list
let scores = [3 8 4]
$"total = ($scores | reduce { |it, acc| $acc + $it })"
```

---

```nushell frame="terminal"
# initial value for accumulator value can be set with `--fold`
$"total = ($scores | reduce --fold 1 { |it, acc| $acc * $it })"
```

---

```nushell frame="terminal"
# gives access to the 3rd item in the list
let planets = [Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune]
$planets.2
```

---

```nushell frame="terminal"
# checks if any string in the list starts with `E`
let planets = [Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune]
$planets | any {|it| $it | str starts-with "E" }
```

---

```nushell frame="terminal"
# creates slice of items that satisfy provided condition
let cond = {|x| $x < 0 }; [-1 -2 9 1] | take while $cond
```

## Tables

```nushell frame="terminal"
# sorting table by size of files
ls | sort-by size
```

---

```nushell frame="terminal"
# sorting table by size of files and show first 5 entries
ls | sort-by size | first 5
```

---

```nushell frame="terminal"
# concatenate two tables with same columns
let $a = [[first_column second_column third_column]; [foo bar snooze]]
let $b = [[first_column second_column third_column]; [hex seeze feeze]]
$a | append $b
```

---

```nushell frame="terminal"
# remove the last column of a table
let teams_scores = [[team score plays]; ['Boston Celtics' 311 3] ['Golden State Warriors', 245 2]]
$teams_scores | drop column
```

## Files & Filesystem

```nushell frame="terminal"
# opens a text file with the default text editor
start file.txt
```

---

```nushell frame="terminal"
# saves a string to text file
'lorem ipsum ' | save file.txt
```

---

```nushell frame="terminal"
# appends a string to the end of file.txt
'dolor sit amet' | save --append file.txt
```

---

```nushell frame="terminal"
# saves a record to file.json
{ a: 1, b: 2 } | save file.json
```

---

```nushell frame="terminal"
# searches for `.rs` and `.toml` files recursively up to 2 folders deep
glob **/*.{rs,toml} --depth 2
```

---

```nushell frame="terminal"
# runs cargo test whenever a Rust file changes
watch . --glob=**/*.rs {|| cargo test }
```

---

## Custom Commands

```nushell frame="terminal"
# custom command with parameter type set to string
    def greet [name: string] {
        $"hello ($name­)"
    }
```

---

```nushell frame="terminal"
# custom command with default parameter set to nushell
    def greet [name = "nushell"] {
        $"hello ($name­)"
    }
```

---

```nushell frame="terminal"
# passing named parameter by defining flag for custom commands
    def greet [
        name: string
        --age: int
    ] {
        [$name $age]
    }

    greet world --age 10
```

---

```nushell frame="terminal"
# using flag as a switch with a shorthand flag (-a) for the age
    def greet [
        name: string
        --age (-a): int
        --twice
    ] {
        if $twice {
            [$name $age $name $age]
        } else {
            [$name $age]
        }
    }
    greet -a 10 --twice hello
```

---

```nushell frame="terminal"
#custom command which takes any number of positional arguments using rest params
    def greet [...name: string] {
        print "­hello all:"
        for $n in $name {
            print $n
        }
    }

    greet earth mars jupiter venus
```

## Variables & Subexpressions

```nushell frame="terminal"
# an immutable variable cannot change its value after declaration
let val = 42
print $val
```

---

```nushell frame="terminal"
# shadowing variable (declaring variable with the same name in a different scope)
let val = 42
do { let val = 101;  $val }
# outputs 101
$val
# outputs 42
```

---

```nushell frame="terminal"
# declaring a mutable variable with mut key word
mut val = 42
$val += 27
$val
```

---

```nushell frame="terminal"
# closures and nested defs cannot capture mutable variables from their enviro­nment.
# this expression results in error.
mut x = 0
[1 2 3] | each { $x += 1 }
```

---

```nushell frame="terminal"
# a constant variable is immutable value which is fully evaluated at parse-time
const plugin = 'path/­to/­plugin'
register $plugin
```

---

```nushell frame="terminal"
# using question mark operator to return null instead of error if provided path is incorrect
let files = (ls)
$files.na­me?.0?
```

---

```nushell frame="terminal"
# using subexp­ression by wrapping the expression with parent­heses ()
let big_files = (ls | where size > 10kb)
$big_files
```

---

## Modules

```nushell frame="terminal"
# using inline module
    module greetings {
        export def hello [name: string] {
            $"hello ($name­)!"
        }

        export def hi [where: string] {
            $"hi ($where)!­"
        }
    }

    use greetings hello
    hello "­wor­ld"
```

---

```nushell title="greetings.nu"
# importing module from file and using its enviro­nment in current scope
    export-env {
        $env.M­YNAME = "­Arthur, King of the Briton­s"
    }
    export def hello [] {
        $"hello ($env.M­YN­AME­)"
    }

    use greeti­ngs.nu
    $env.M­YNAME
    # outputs: Arthur, King of the Britons
    greetings hello
    #outputs: hello Arthur, King of the Britons!
```

---

```nushell title="greetings.nu"
    # using main command in module
    export def hello [name: string] {
        $"hello ($name­)!"
    }

    export def hi [where: string] {
        $"hi ($where)!­"
    }

    export def main [] {
        "­gre­etings and salutations!"
    }

    use greeti­ngs.nu
    greetings
    # outputs: greetings and saluta­tions!
    greetings hello world
    # outputs: hello world!
```

---
