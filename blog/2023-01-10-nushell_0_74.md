---
title: Nushell 0.74
author: The Nu Authors
author_site: https://twitter.com/nu_shell
author_image: https://www.nushell.sh/blog/images/nu_logo.png
excerpt: Today, we're releasing version 0.74 of Nu. This release includes many command refinements.
---

# Nushell 0.74

Nushell, or Nu for short, is a new shell that takes a modern, structured approach to your command line. It works seamlessly with the data from your filesystem, operating system, and a growing number of file formats to make it easy to build powerful command line pipelines.

Today, we're releasing version 0.74 of Nu. This release includes many command refinements.

<!-- more -->

# Where to get it

Nu 0.74 is available as [pre-built binaries](https://github.com/nushell/nushell/releases/tag/0.74.0) or from [crates.io](https://crates.io/crates/nu). If you have Rust installed you can install it using `cargo install nu`.

NOTE: The optional dataframe functionality is available by `cargo install nu --features=dataframe`.

As part of this release, we also publish a set of optional plugins you can install and use with Nu. To install, use `cargo install nu_plugin_<plugin name>`.

# Themes of this release / New features

## Known externals commands and `exec` now have "fall-through" signatures ([merelymyself, WindSoilder, kubouch](https://github.com/nushell/nushell/pull/7527))

A common pitfall in Nushell when defining custom signatures using `extern` used to be that unrecognized arguments passed to the command would throw an error. Now, arguments are still checked against the `extern` signature but those that are not recognized are simply ignored.

```sh
> extern `git checkout` []
> git checkout -b foo  # does not throw an error
```

`exec` uses similar style which fixes errors with tools like `ssh` and `gdb` that internally invoke `exec`.

```sh
> nu -c 'exec ls -l'  # does not throw an error
```

## Initial support for parse-time constants ([kubouch](https://github.com/nushell/nushell/pull/7436))

_This is a proof-of-concept that we plan to expand in the future._

A new `const` keyword is added to Nushell to define "parse-time" constants. Constants defined with `const` behave the same as variables defined with `let`, but in addition, they are usable in some contexts that require values known at parse-time. Currently, this applies to files or names passed to `use`, `overlay use`, `source`, and `source-env`. For example, the following now works:

```sh
# Source a file from a constant
> 'print hello!' | save --raw say_hello.nu
> const fname = 'say_hello.nu'
> source $fname
hello!
```

```sh
# Load an overlay from a constant name:
> module spam {
	export def foo [] { 'foo' }
}
> const name = 'spam'
> const new_name = 'eggs'
> overlay use $name as $new_name
> overlay list | last
eggs
> foo
foo
```

Only a limited subset of values is allowed to be a constant. In general, "simple" values, like strings or integers, and their collections (lists, records) are allowed but values requiring some evaluation (string interpolation, subexpressions, environment variables) are not allowed. The current selection is not set in stone, however, and might change in the future.

Some future direction we can take this:

- Move parts of `$nu` to be constant to allow things like `source $nu.config-path`
- Allow modules to have constants (`module spam { const CONTENTS = [ 'eggs', 'bacon', 'sausage', 'spam' ] }`)
- Some limited form of parse-time evaluation to allow static control flow, for example

```
const fname = const if $nu.os-info.name == 'windows' {
    'C:\Users\viking\spam.nu'
} else {
    '/home/viking/spam.nu'
}
overlay use $fname
```

In general, we want to be very conservative with parse-time constants and evaluation because it can be easy to introduce awkward side-effects and performance pitfalls. We plan to extend this only where it brings some tangible benefit to Nushell's user experience.

## `help` is now more helpful ([kubouch](https://github.com/nushell/nushell/pull/7611))

For a long time, Nushell had the option to provide custom help messages for commands via comments:

```
# Some Command
#
# More description goes here
def some-command [] { 'foo' }

help some-command  # displays the comments in the help message
```

In this release, we allow user-defined help messages with aliases and modules. This goes hand-in-hand with a handful of new `help` subcommands to explore these help messages.

The help messages now also treat the first line followed by an empty line as a "brief" description displayed in summary tables generated by `help commands`, `$nu.scope.aliases`, etc. The full description is available when querying a particular command/alias/module (e.g., `help spam`). This brief vs. full separation was already present for built-in commands, like `path`, but now it is applied also to all user-defined help messages.

![Help messages for modules and aliases](../assets/images/0_74_new_help.png)

The current batch of improvements can still be taken further. For example, custom help messages could possibly be defined also for variables and environment variables (via comments adjacent to `let` and `let-env`). We could also further improve the presentation of existing `help xxx` commands.

## `values` command to programmatically interact with records ([webbedspace](https://github.com/nushell/nushell/pull/7583))

```sh
>  {a: "Happy", b: "new", c: "year"} | values
╭───┬───────╮
│ 0 │ Happy │
│ 1 │ new   │
│ 2 │ year  │
╰───┴───────╯
```

## MIME-types are supported in `ls` with an additional flag. ([fdncred](https://github.com/nushell/nushell/pull/7616))

To find out what applications your operating system associates with particular files you can now use the `--mime-type` or `-m` flag on our `ls` command.
This simplifies filtering for particular files and can help you dispatch files to particular programs.
When opening files with nushell directly `open` will still follow the same heuristics using file endings and the built-in `from ...` command parsers.

## Regular expression queries are cached for performance ([rgwood](https://github.com/nushell/nushell/pull/7587))

Stonksmeme.png

## All built-in commands now declare their pipeline input and output types ([sholderbach](https://github.com/nushell/nushell/pull/7532))

A few releases back commands internally got the capability to declare not only the types of parameters but also pairs for the input and output on the pipeline.
With this release we finally declare those input and output types for all core nushell commands.
This can help you as user to see what a command expects from the pipeline and might return.
We are exploring how nushell can leverage that for more useful diagnostics and completions. In the future we may introduce syntax for user-defined commands to declare their input and output types explicitly.

![help for wrap command shows I/O type signatures](../assets/images/0_74_io_signatures.png)

# Breaking changes

- `columns` will now error for data that is not a table or a record ([#7593](https://github.com/nushell/nushell/pull/7593))
- The dataframe specific command `fill-na` has been renamed to `fill-nan` to better represent its capabilities ([#7565](https://github.com/nushell/nushell/pull/7565))
- The requirements for the names of a nu command and a command alias have been tightened to avoid some problems ([#7392](https://github.com/nushell/nushell/pull/7392))
- `to toml` will only produce output for records now as the output for tables is ambiguous and may be invalid to parse ([#7597](https://github.com/nushell/nushell/pull/7597))
- `exec` and known externals don't throw errors when unknowns parameters are passed to them
- `use`, `overlay use`, `source`, and `source-env` now accept constants defined with `const` as arguments
- `help` command has been thoroughly refactored and includes several more subcommands
- command names in `help commands` and `$nu.scope.commands` are displayed correctly if they were inported from a module with a prefix

# Full changelog
