---
title: Nushell 0.68
author: The Nu Authors
author_site: https://twitter.com/nu_shell
author_image: https://www.nushell.sh/blog/images/nu_logo.png
excerpt: Today, we're releasing version 0.68 of Nu.
---

# Nushell 0.68

Nushell, or Nu for short, is a new shell that takes a modern, structured approach to your commandline. It works seamlessly with the data from your filesystem, operating system, and a growing number of file formats to make it easy to build powerful commandline pipelines.

Today, we're releasing version 0.68 of Nu. This is release includes a new variable naming convention, improvements to module imports and file sourcing, and more.

<!-- more -->

# Where to get it

Nu 0.68 is available as [pre-built binaries](https://github.com/nushell/nushell/releases/tag/0.68.0) or from [crates.io](https://crates.io/crates/nu). If you have Rust installed you can install it using `cargo install nu`.

If you want all the built-in goodies, you can install `cargo install nu --features=extra`.

As part of this release, we also publish a set of optional plugins you can install and use with Nu. To install, use `cargo install nu_plugin_<plugin name>`.

# Themes of this release

## (Major changes!) Rework of modules and environment (kubouch, JT)

_Some of the changes here have far-reaching consequences and it might take a while to get the book up to speed._

This release includes a bundle of changes to environment handling and modules.
For now, we kept also the old functionality, but in the 0.69, it will be removed.
It is therefore recommended to port your scripts and modules to the new style to avoid breakages in the next release.
You can read a more complete write-up on the motivation and overall design in [this document](https://hackmd.io/@nucore/r1zilyw6q).

### `source` removal ([JT, kubouch](https://github.com/nushell/nushell/pull/6277))

One of the most common pitfalls of Nushell was trying to `source` a dynamic path, such as `source ($env.PWD | path join foo.nu)`.
Since Nushell is a "compiled" language where commands and aliases are analyzed while parsing ("compiling") the code, sourcing dynamic paths is not possible for the same reason you cannot dynamically set `#include` file names in C or `use` modules in Rust.
You can read a bit more about this in [our Thinking in Nu book chapter](https://www.nushell.sh/book/thinking_in_nu.html#think-of-nushell-as-a-compiled-language).

To address this pitfall, we decided to change `source` to `source-env` which can be used to bring in the environment, but not custom commands, aliases and variables anymore.
A benefit of doing so is that it is now **possible to pass dynamic paths**: `source-env ($env.PWD | path join foo.nu)` would bring in the environment from the `foo.nu` file.

_How do you bring in commands and aliases without `source`?_ You need to use a module and the `use` keyword. See our book chapter [about modules](https://www.nushell.sh/book/modules.html), it's quite simple. Alternatively, you can use [overlays](https://www.nushell.sh/book/overlays.html).

_How do you bring in variables without `source`?_ This is not possible anymore. A workaround is to define a command in your module that will return the value you want.

`source` still continues to work in this release but will be removed in 0.69. In 0.69, we will also change all config files to be modules, not plain scripts.

### Module envrionment changes

The way to define environment variables from modules used to be
```
> module spam {
    export env FOO { 'bar' }
}

> use spam
```
This example shows one problem: it is easy to end up with namespaced environment variables, which in this case would be `$env.'spam FOO'`.
Another problem with the current design is that `use` is a parser keyword (like the removed `source`) but contains both parser ("compiled") and runtime (evaluated) functionality.
Since 0.67, it is possible to [use modules within other modules](https://github.com/nushell/nushell/pull/6162) but because environment is 100% handled in runtime, and `use` never evaluates the module itself, it was impossible to bring in environment variables from other modules inside a module.

Long story short, `use` (and `hide`) now handle **only custom commands and aliases**, not environment variables anymore.
If you want to bring both environment and commands/aliases, you need to use the `source-env` and `use` commands separately (or use overlays).

Also, we simplified defining the environment in modules. Instead of defining environment variables with `export env` individually, there is a single `export-env { }` block for the whole module (see the example in the next section).

If you call `source-env` on that module, the `export-env` command will get evaluated and its environment kept in the current scope.
```
# spam.nu

export-env {
    let-env FOO = 'foo'
    let-env BAR = 'bar'
}
```
```
> source-env spam.nu

> $env.FOO
foo

> $env.BAR
bar
```

This release makes `export env` deprecated and it will be removed in 0.69.

### Syntax unification

Previously, modules had some reserved syntax that was not valid in scripts: the `export` keywords.
In this release, we allowed `export` keywords to be used in scripts (they do nothing: `export def` acts as `def` etc.) and thus **script syntax is a superset of module syntax**.
Modules can now be evaluated.
This is the reason the above example with `source-env` works: Thanks to the unified syntax, `source-env` will evaluate the module which evaluates the `export-env` command inside the module.

Another nice thing about the unified syntax is that commands like `nu-highlight` now do not break or do not need to rely on heuristics if they are asked to parse a module code.
Any module code is a valid script code.

### Overlays

`overlay add` and `overlay remove` are now renamed to `overlay use` and `overlay hide` (see the breaking changes later).

The functionality of these commands remains largely the same with one change being that `overlay use` will now evaluate the `export-env { }` block.
Consider this module:
```
# spam.nu

export-env {
    load-env {
        FOO: 'foo'
        BAR: 'bar'
    }
}

export def foo [] { 'foo' }
export alias bar = 'bar'
```
instead of:
```
> source-env spam.nu

> use spam.nu *
```
you can do just:
```
> overlay use spam.nu
```
You can think of `overlay use` as calling `source-env` and `use` in one command and putting the result into a new overlay.

### Summary

Here is a table that summarizes the changes:

| command | previous release (0.67) | this release (0.68) | next release (0.69) |
| ------- | ----------------------- | ------------------- | ---
| `source`  | imports everything into the current scope | same (deprecated) | removed |
| `source-env` | N/A | imports environment variables | same |
| `use` | imports environment variables, commands and aliases | same | imports only commands and aliases |
| `hide` | hides enviornment variables, commands and aliases | same | hides only commands and aliases |
| `hide-env` | hides environment variables | same | same |
| `export env` | defines a single environment variable in a module | same | removed |
| `export-env` | N/A | (in a module) defines the envrionment for the whole module | same |
| `export-env` | N/A | (in a script) when evaluated, preserves the environment from the block | same |
| `export ...` | only allowed in a module | allowed in a script as well | same |
| `config.nu`  | plain script | plain script | module |
| `env.nu`  | plain script | plain script | module |
| `login.nu`  | plain script | plain script | module |


## We added a new command `str distance` which impelments the Levenshtein alorithm [fdncred](https://github.com/nushell/nushell/pull/6383)

This example shows that the `edit distance` is one edit step difference using the Levenshtein algorithm.

```sh
> 'nushell' | str distance 'nutshell'
╭──────────┬───╮
│ distance │ 1 │
╰──────────┴───╯
```

We'd eventually like to add more similarity comparision functionality to nushell.

## We added string duration conversion to named durations [fdncred](https://github.com/nushell/nushell/pull/6406)

The new parameter on `into duration` `--convert` allows you to convert from string durations into named durations.

```sh
> '7min' | into duration --convert sec
420 sec
```

# Breaking changes

## Renaming of `all?` to `all`, `any?` to `any`, and `empty?` to `is-empty` ([adamijak](https://github.com/nushell/nushell/pull/6464))

The `?` suffix on the three commands `all?`, `any?`, `empty?` did not indicate a specific meaning across other commands.
Other commands returning a boolean value, like `str contains` for example, don't carry the suffix.
To remove a potential source of confusion and to free up the `?` for potential use in a more meaningful semantic context, we decided to remove the suffix and rename `empty?` to `is-empty` to clarify its role.

Please update your scripts accordingly:

| old name | new name   |
| -------- | ---------- |
| `all?`   | `all`      |
| `any?`   | `any`      |
| `empty?` | `is-empty` |

## Renaming `overlay` commands ([WindSoilder](https://github.com/nushell/nushell/pull/6375))

| old name | new name   |
| -------- | ---------- |
| `overlay add`   | `overlay use`      |
| `overlay remove`   | `overlay hide`      |

The main reason is that the `overlay remove` does not _really_ remove the overlay.
It deactivates it and it can be resumed again from where you left off.
Therefore, we felt like `hide` is a better word to match this functionality and aligns with our existing `use` and `hide` keywords.

## `path split` behaviour for Windows paths ([merelymyself](https://github.com/nushell/nushell/pull/6485))

`path split` no longer returns drive letters and the root directory as seperate elements for absolute Windows paths.

Previously, `` `C:\temp` | path split`` returned `C:`, `\`, and `temp`. Now it returns `C:\` and `temp`.

# Next Steps

Time for a new engine!

We've been looking through the fixes we'd need for some of the issues we're seeing and decided Nushell's core needs a thorough refactor. On [this Notion page](https://kubouch.notion.site/4db276462ba24704919edb4cc4b86be7?v=10506505557f4f7b9a65155128c04250) we started gathering ideas and design notes about features that we think should make it to the update. You can click the cards and they should expand into more detailed notes.

Many (most?) ideas are not polished yet and we need to work on the full design before we start the implementation. Therefore, we would like you to invite you to participate in the discussion. If you have questions, comments and ideas, please channel them to our `#design-discussion` channel on [our Discord](https://discord.com/invite/NtAbbGn). We especially welcome thorough design writeups. You can even "adopt" a topic and specialize in it, if you wish. And of course, later, we'll need help implementing everything.

By the end of this, we'll be heading towards 0.80 which should have all, or most of, the features we want for 1.0 and the work from 0.80 to 1.0 is expected to be mostly polish, bugfixes, IDE integrations, stabilizing the language, etc.

Oh, and if you're scared this will turn into another engine-q, this time our goal is to try to make the updates incrementally instead of building a new Nushell on the side and then replacing everything.

# Full changelog
